学习状压dp之前，请确认你已经完成了[动态规划初步](/dp/)部分内容的学习

(建议学习[位运算](/math/bit/)部分的内容)

### 状压dp简介
状压dp是动态规划的一种，借由将状态压缩（通常压缩为某整形）以达到节约空间和时间的目的
### 什么时候用？
1. 数据范围   
范围在20左右时正常的状压~~当然凡事有二般情况~~  
很多时候会有一些NP问题会用状压求解。
2. 是否可以压缩  
一般的状态压缩都是选择或者不选择，放或者不放，遇见这种东西一般时状压。八皇后问题也是一个状压的代表。  
3. 常见题目模型  
比如TSP，覆盖问题之类的。经常会有这种模型的题出现就可以使用状压。   
#### 常用格式

```cpp
int maxn=1<<n; //规定状态的上界
for (int i=0;i<maxn;i++){
	if (i&(i<<1)) continue;//如果i情况不成立就忽略
	Type[++top]=i;//记录情况i到Type数组中
}
for (int i=1;i<=top;i++){
	if (fit(situation[1],Type[i]))
    	dp[1][Type[i]]=1;//初始化第一层
}
for (int i=2;i<=层数(dp上界);i++){
	for (int l=1;l<=top;l++)//穷举本层情况
    	for (int j=1;j<=top;j++)//穷举上一层情况(上一层对本层有影响时)
        	if (situation[i],Type[l]和Type[j]符合题意)
            	dp[i][l]=dp[i][l]+dp[i-1][j];//改变当前层(i)的状态(l)的方案种数
}
for (int i=1;i<=top;i++) ans+=dp[上界][Type[i]];
```

#### 典型例题

[[USACO06NOV]玉米田Corn Fields](https://www.luogu.org/problemnew/show/P1879)

显然，这是一道典型的动态规划题目，但由于方案数过多，应使用状压dp避免超时

本题所"压缩"的是"每行可行的状态"和"每行土地的状态",而储存答案的dp数组就应同时体现这两个特点(所以本题dp数组为二维)

upt:
##### _TSP问题_

给你n个城市和城市之间的通路的长度，找出一条经过所有城市一次且仅经过一次的路线，使得这条路线的长度最短。  
因为设计路线，所以状态肯定与你现在所在的城市有关系。其次，你还需要保存经过了哪些城市（不能重复走）。如果一个城市被经过了用1表示，没有到过用0表示一个整数就可以表示所有城市是否被走过，那么可以得到$dp[i][j]$其中i表示当前经过和没有经过的（二进制），j表示你站在j城市。所以方程容易得到：   
$dp[i][j]=min\{dp[i|(1<<(j-1))][k]+w[j][k]\}$  
##### NOI2001 炮兵布阵   
[====传送门====](https://www.luogu.org/problemnew/show/P2704)   
此题暴力肯定超时，怎么办呢？  
因为m<=10，所以每一行的状态肯定可以表示成一个整数。还是假设放置是1，不放是0.    
然后我们可以枚举一行中的所有的状态（可以打表啦），而且手推一下会发现一行状态数量是很少的。（不会超过100）    
于是我们记录了所有状态的士兵数量。根据题意我们明显发现，每一行只与其前两行有关系。因此我们假设  

$dp[i,st1,st2]$为当前第i行用第st1种状态，然后i-1行用第st2种方案。转移时穷举i-2行所有的状态。   

前面说过，第i行仅仅和i-1 i-2有关系，所以列出方程：

$dp[i,st1,st2]=max\{dp[i-1,st2,j]+sum[st1]\}$    
其中j是枚举的i-2行状态，sum代表这种状态下的数量。     

下面就是状态是否可行的问题了。首先，第i行的状态肯定不可以和环境冲突啊！    
第i行如果和环境冲突，那么肯定在有山的地方放了1。怎样判断比较快？输入的时候就转化成二进制。如果有山这位就是1，若果没有就是0.这个时候，如果原地形是0，则第i行状态可以是1/0，如果原来是1，则第i行必须是0.这不就是按位与运算吗？如果原地形和第i行的状态and一下后不是0，那么自然代表状态不成立（出现了两个1！）所以这里判断只需要一次与运算。   

然后判断当前行和上面一行冲突是否。这里我们发现和判读地形一样，不能同为1，所以也是一遍与运算。    
判断当前行与上上行，仍然是一遍与运算。   

最后捋一遍思路
- 把输入的字符串变成一个整数（按照二进制转十进制）
- 枚举i（2-n）
- 枚举第i行状态
- 判断是否与地图冲突（&）
- 枚举第i-1行状态
- 判断
- 枚举第i-2行
- 判断（别忘了特判第二行！）
- dp方程。。




[例题代码](https://www.luogu.org/paste/kto3ua68) (第一题)
